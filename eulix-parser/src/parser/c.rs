use crate::kb::types::*;
use regex::Regex;
use std::collections::{HashMap, HashSet};
use std::path::Path;
use tree_sitter::{Node, Parser};
// NOTE THIS IS GENERATED BY CLAUDE I NEED A C PARSER QUICKLY
// SO WENT WITH IT, WILL FIX CHANGES IF NEEDED

pub struct CParser {
    source_code: String,
}

impl CParser {
    pub fn new(source_code: String) -> Self {
        // let lines: Vec<String> = source_code.lines().map(|s| s.to_string()).collect();
        Self { source_code }
    }

    pub fn parse(&self) -> Result<FileData, String> {
        let mut parser = Parser::new();
        parser
            .set_language(tree_sitter_c::language())
            .map_err(|e| format!("Failed to load C grammar: {}", e))?;

        let tree = parser
            .parse(&self.source_code, None)
            .ok_or_else(|| "Failed to parse C file".to_string())?;

        let root = tree.root_node();

        Ok(FileData {
            language: "c".to_string(),
            loc: self.count_lines(),
            imports: self.extract_imports(&root),
            functions: self.extract_functions(&root),
            classes: self.extract_structs(&root),
            global_vars: self.extract_global_vars(&root),
            todos: self.extract_todos(),
            security_notes: self.detect_security_patterns(),
        })
    }

    fn count_lines(&self) -> usize {
        self.source_code.lines().count()
    }

    fn extract_imports(&self, root: &Node) -> Vec<Import> {
        let mut imports = Vec::new();
        let mut cursor = root.walk();

        for child in root.children(&mut cursor) {
            if child.kind() == "preproc_include" {
                let text = self.get_node_text(&child);

                // Extract the include path
                if let Some(path_match) = Regex::new(r#"#include\s*[<"]([^>"]+)[>"]"#)
                    .ok()
                    .and_then(|re| re.captures(&text))
                {
                    let path = path_match.get(1).unwrap().as_str().to_string();
                    let is_system = text.contains('<');

                    imports.push(Import {
                        module: path.clone(),
                        items: vec![],
                        import_type: self.classify_import(&path, is_system),
                    });
                }
            }
        }

        imports
    }

    fn classify_import(&self, path: &str, is_system: bool) -> String {
        // Standard C library headers
        let stdlib = [
            "stdio.h", "stdlib.h", "string.h", "math.h", "time.h",
            "ctype.h", "stdint.h", "stdbool.h", "stddef.h", "assert.h",
            "errno.h", "limits.h", "float.h", "stdarg.h", "signal.h",
            "setjmp.h", "locale.h", "wchar.h", "wctype.h", "complex.h",
            "fenv.h", "inttypes.h", "iso646.h", "stdalign.h", "threads.h",
            "unistd.h", "pthread.h", "sys/", "fcntl.h",
        ];

        if stdlib.iter().any(|s| path.starts_with(s)) || is_system {
            "stdlib".to_string()
        } else if path.starts_with('.') || !path.contains('/') {
            "internal".to_string()
        } else {
            "external".to_string()
        }
    }

    fn extract_functions(&self, root: &Node) -> Vec<Function> {
        let mut functions = Vec::new();
        let mut cursor = root.walk();

        for child in root.children(&mut cursor) {
            if child.kind() == "function_definition" {
                if let Some(func) = self.parse_function(&child, "") {
                    functions.push(func);
                }
            }
        }

        functions
    }

    fn parse_function(&self, node: &Node, struct_context: &str) -> Option<Function> {
        let declarator = node.child_by_field_name("declarator")?;
        let name = self.extract_function_name(&declarator)?;

        let params = self.extract_parameters(&declarator);
        let return_type = node.child_by_field_name("type")
            .map(|t| self.get_node_text(&t))
            .unwrap_or_else(|| "void".to_string());

        let line_start = node.start_position().row + 1;
        let line_end = node.end_position().row + 1;
        let docstring = self.extract_docstring(node);
        let signature = self.build_signature(&name, &params, &return_type);

        let body = node.child_by_field_name("body")?;
        let calls = self.extract_function_calls_detailed(&body);
        let variables = self.extract_variables(&body, &params);
        let control_flow = self.build_control_flow(&body);
        let exceptions = ExceptionInfo::default(); // C doesn't have exceptions
        let complexity = self.calculate_complexity(&body);

        let id = if struct_context.is_empty() {
            format!("func_{}", name)
        } else {
            format!("method_{}_{}", struct_context, name)
        };

        let tags = self.auto_tag_function(&name, &docstring, &calls, &return_type);
        let importance_score = self.estimate_importance(&name, &return_type);

        Some(Function {
            id,
            name,
            signature,
            params,
            return_type,
            docstring,
            line_start,
            line_end,
            calls,
            called_by: vec![],
            variables,
            control_flow,
            exceptions,
            complexity,
            is_async: false,
            decorators: vec![],
            tags,
            importance_score,
        })
    }

    fn extract_function_name(&self, declarator: &Node) -> Option<String> {
        match declarator.kind() {
            "function_declarator" => {
                if let Some(decl) = declarator.child_by_field_name("declarator") {
                    self.extract_function_name(&decl)
                } else {
                    None
                }
            }
            "pointer_declarator" => {
                if let Some(decl) = declarator.child_by_field_name("declarator") {
                    self.extract_function_name(&decl)
                } else {
                    None
                }
            }
            "identifier" => Some(self.get_node_text(declarator)),
            _ => None,
        }
    }

    fn extract_parameters(&self, declarator: &Node) -> Vec<Parameter> {
        let mut params = Vec::new();

        fn find_params(node: &Node, parser: &CParser, params: &mut Vec<Parameter>) {
            if node.kind() == "parameter_list" {
                let mut cursor = node.walk();
                for child in node.children(&mut cursor) {
                    if child.kind() == "parameter_declaration" {
                        let _param_text = parser.get_node_text(&child);

                        let type_node = child.child_by_field_name("type");
                        let declarator_node = child.child_by_field_name("declarator");

                        let type_annotation = type_node
                            .map(|t| parser.get_node_text(&t))
                            .unwrap_or_default();

                        let name = if let Some(decl) = declarator_node {
                            parser.extract_declarator_name(&decl)
                        } else {
                            // Anonymous parameter
                            format!("_param{}", params.len())
                        };

                        params.push(Parameter {
                            name,
                            type_annotation,
                            default_value: None,
                        });
                    } else if child.kind() == "..." {
                        params.push(Parameter {
                            name: "...".to_string(),
                            type_annotation: "variadic".to_string(),
                            default_value: None,
                        });
                    }
                }
            } else {
                let mut cursor = node.walk();
                for child in node.children(&mut cursor) {
                    find_params(&child, parser, params);
                }
            }
        }

        find_params(declarator, self, &mut params);
        params
    }

    fn extract_declarator_name(&self, declarator: &Node) -> String {
        match declarator.kind() {
            "identifier" => self.get_node_text(declarator),
            "pointer_declarator" | "array_declarator" | "function_declarator" => {
                if let Some(decl) = declarator.child_by_field_name("declarator") {
                    self.extract_declarator_name(&decl)
                } else {
                    String::new()
                }
            }
            _ => String::new(),
        }
    }

    fn build_signature(&self, name: &str, params: &[Parameter], return_type: &str) -> String {
        let param_str = params
            .iter()
            .map(|p| {
                if p.name.starts_with('_') && p.name != "..." {
                    p.type_annotation.clone()
                } else {
                    format!("{} {}", p.type_annotation, p.name)
                }
            })
            .collect::<Vec<_>>()
            .join(", ");

        format!("{} {}({})", return_type, name, param_str)
    }

    fn extract_function_calls_detailed(&self, node: &Node) -> Vec<FunctionCall> {
        let mut calls = Vec::new();
        let mut seen = HashSet::new();
        self.find_calls_recursive(node, &mut calls, &mut seen, "unconditional");
        calls
    }

    fn find_calls_recursive(&self, node: &Node, calls: &mut Vec<FunctionCall>, seen: &mut HashSet<String>, context: &str) {
        let mut cursor = node.walk();

        let child_context = match node.kind() {
            "if_statement" => "if",
            "for_statement" | "while_statement" | "do_statement" => "loop",
            "switch_statement" => "switch",
            _ => context,
        };

        if node.kind() == "call_expression" {
            if let Some(func_node) = node.child_by_field_name("function") {
                let call_text = self.get_node_text(&func_node);
                let name = call_text
                    .split(|c: char| c == '.' || c == '-' || c == '>')
                    .last()
                    .unwrap_or(&call_text)
                    .trim()
                    .to_string();

                if !name.is_empty() {
                    let key = format!("{}:{}", name, node.start_position().row);
                    if !seen.contains(&key) {
                        seen.insert(key);

                        let args = self.extract_call_arguments(node);

                        calls.push(FunctionCall {
                            callee: name,
                            defined_in: None,
                            line: node.start_position().row + 1,
                            args,
                            is_conditional: context != "unconditional",
                            context: context.to_string(),
                        });
                    }
                }
            }
        }

        for child in node.children(&mut cursor) {
            self.find_calls_recursive(&child, calls, seen, child_context);
        }
    }

    fn extract_call_arguments(&self, call_node: &Node) -> Vec<String> {
        let mut args = Vec::new();

        if let Some(arg_list) = call_node.child_by_field_name("arguments") {
            let mut cursor = arg_list.walk();
            for child in arg_list.children(&mut cursor) {
                if child.kind() != "(" && child.kind() != ")" && child.kind() != "," {
                    args.push(self.get_node_text(&child));
                }
            }
        }

        args
    }

    fn extract_variables(&self, node: &Node, params: &[Parameter]) -> Vec<Variable> {
        let mut variables: HashMap<String, Variable> = HashMap::new();

        for param in params {
            if !param.name.starts_with('_') && param.name != "..." {
                variables.insert(param.name.clone(), Variable {
                    name: param.name.clone(),
                    var_type: if param.type_annotation.is_empty() {
                        None
                    } else {
                        Some(param.type_annotation.clone())
                    },
                    scope: "param".to_string(),
                    defined_at: None,
                    transformations: vec![],
                    used_in: vec![],
                    returned: false,
                });
            }
        }

        self.track_variable_usage(node, &mut variables);
        variables.into_values().collect()
    }

    fn track_variable_usage(&self, node: &Node, variables: &mut HashMap<String, Variable>) {
        let mut cursor = node.walk();

        if node.kind() == "declaration" {
            if let Some(decl) = node.child_by_field_name("declarator") {
                let var_name = self.extract_declarator_name(&decl);
                if !var_name.is_empty() {
                    let line = node.start_position().row + 1;
                    let var_type = node.child_by_field_name("type")
                        .map(|t| self.get_node_text(&t));

                    if !variables.contains_key(&var_name) {
                        variables.insert(var_name.clone(), Variable {
                            name: var_name,
                            var_type,
                            scope: "local".to_string(),
                            defined_at: Some(line),
                            transformations: vec![],
                            used_in: vec![],
                            returned: false,
                        });
                    }
                }
            }
        } else if node.kind() == "return_statement" {
            let mut ret_cursor = node.walk();
            for child in node.children(&mut ret_cursor) {
                if child.kind() == "identifier" {
                    let var_name = self.get_node_text(&child);
                    if let Some(var) = variables.get_mut(&var_name) {
                        var.returned = true;
                    }
                }
            }
        }

        for child in node.children(&mut cursor) {
            self.track_variable_usage(&child, variables);
        }
    }

    fn build_control_flow(&self, node: &Node) -> ControlFlow {
        let mut control_flow = ControlFlow {
            complexity: self.calculate_complexity(node),
            branches: vec![],
            loops: vec![],
            try_blocks: vec![],
        };

        self.extract_control_structures(node, &mut control_flow);
        control_flow
    }

    fn extract_control_structures(&self, node: &Node, cf: &mut ControlFlow) {
        let mut cursor = node.walk();

        match node.kind() {
            "if_statement" => {
                if let Some(branch) = self.parse_if_statement(node) {
                    cf.branches.push(branch);
                }
            }
            "for_statement" | "while_statement" | "do_statement" => {
                if let Some(loop_info) = self.parse_loop(node) {
                    cf.loops.push(loop_info);
                }
            }
            _ => {}
        }

        for child in node.children(&mut cursor) {
            self.extract_control_structures(&child, cf);
        }
    }

    fn parse_if_statement(&self, node: &Node) -> Option<Branch> {
        let line = node.start_position().row + 1;
        let condition = node.child_by_field_name("condition")
            .map(|c| self.get_node_text(&c))
            .unwrap_or_default();

        let consequence = node.child_by_field_name("consequence")?;
        let true_path = self.extract_execution_path(&consequence)?;

        let false_path = node.child_by_field_name("alternative")
            .and_then(|alt| self.extract_execution_path(&alt));

        Some(Branch {
            branch_type: "if".to_string(),
            condition,
            line,
            true_path,
            false_path,
        })
    }

    fn extract_execution_path(&self, block: &Node) -> Option<ExecutionPath> {
        let calls = self.extract_calls_from_block(block);
        let returns = self.find_return_value(block);
        let raises = None;

        Some(ExecutionPath { calls, returns, raises })
    }

    fn extract_calls_from_block(&self, block: &Node) -> Vec<String> {
        let mut calls = Vec::new();
        let mut seen = HashSet::new();
        self.find_call_names(block, &mut calls, &mut seen);
        calls
    }

    fn find_call_names(&self, node: &Node, calls: &mut Vec<String>, seen: &mut HashSet<String>) {
        let mut cursor = node.walk();

        if node.kind() == "call_expression" {
            if let Some(func_node) = node.child_by_field_name("function") {
                let name = self.get_node_text(&func_node);
                if !seen.contains(&name) {
                    seen.insert(name.clone());
                    calls.push(name);
                }
            }
        }

        for child in node.children(&mut cursor) {
            self.find_call_names(&child, calls, seen);
        }
    }

    fn find_return_value(&self, node: &Node) -> Option<String> {
        let mut cursor = node.walk();

        for child in node.children(&mut cursor) {
            if child.kind() == "return_statement" {
                let mut ret_vals = Vec::new();
                let mut ret_cursor = child.walk();
                for ret_child in child.children(&mut ret_cursor) {
                    if ret_child.kind() != "return" && ret_child.kind() != ";" {
                        ret_vals.push(self.get_node_text(&ret_child));
                    }
                }
                return Some(ret_vals.join(", "));
            }

            if let Some(val) = self.find_return_value(&child) {
                return Some(val);
            }
        }

        None
    }

    fn parse_loop(&self, node: &Node) -> Option<Loop> {
        let line = node.start_position().row + 1;
        let loop_type = match node.kind() {
            "for_statement" => "for",
            "while_statement" => "while",
            "do_statement" => "do-while",
            _ => "unknown",
        };

        let condition = node.child_by_field_name("condition")
            .map(|c| self.get_node_text(&c))
            .unwrap_or_default();

        let calls = self.extract_calls_from_block(node);

        Some(Loop {
            loop_type: loop_type.to_string(),
            condition,
            line,
            calls,
        })
    }

    fn extract_structs(&self, root: &Node) -> Vec<Class> {
        let mut structs = Vec::new();
        let mut cursor = root.walk();

        for child in root.children(&mut cursor) {
            if child.kind() == "declaration" {
                if let Some(struct_data) = self.parse_struct(&child) {
                    structs.push(struct_data);
                }
            }
        }

        structs
    }

    fn parse_struct(&self, node: &Node) -> Option<Class> {
        let type_node = node.child_by_field_name("type")?;

        if type_node.kind() != "struct_specifier" && type_node.kind() != "union_specifier" {
            return None;
        }

        let name = type_node.child_by_field_name("name")
            .map(|n| self.get_node_text(&n))?;

        let line_start = node.start_position().row + 1;
        let line_end = node.end_position().row + 1;
        let docstring = self.extract_docstring(node);

        let attributes = if let Some(body) = type_node.child_by_field_name("body") {
            self.extract_struct_fields(&body)
        } else {
            vec![]
        };

        let struct_type = if type_node.kind() == "union_specifier" {
            "union"
        } else {
            "struct"
        };

        Some(Class {
            id: format!("{}_{}", struct_type, name),
            name,
            bases: vec![],
            docstring,
            line_start,
            line_end,
            methods: vec![],
            attributes,
            decorators: vec![],
        })
    }

    fn extract_struct_fields(&self, body: &Node) -> Vec<Attribute> {
        let mut fields = Vec::new();
        let mut cursor = body.walk();

        for child in body.children(&mut cursor) {
            if child.kind() == "field_declaration" {
                let type_annotation = child.child_by_field_name("type")
                    .map(|t| self.get_node_text(&t))
                    .unwrap_or_default();

                if let Some(decl) = child.child_by_field_name("declarator") {
                    let name = self.extract_declarator_name(&decl);
                    if !name.is_empty() {
                        fields.push(Attribute {
                            name,
                            type_annotation,
                            value: None,
                        });
                    }
                }
            }
        }

        fields
    }

    fn extract_global_vars(&self, root: &Node) -> Vec<GlobalVar> {
        let mut vars = Vec::new();
        let mut cursor = root.walk();

        for child in root.children(&mut cursor) {
            if child.kind() == "declaration" {
                // Check if it's not a function declaration
                if child.child_by_field_name("declarator")
                    .map(|d| d.kind() != "function_declarator")
                    .unwrap_or(true)
                {
                    if let Some(var) = self.parse_global_var(&child) {
                        vars.push(var);
                    }
                }
            }
        }

        vars
    }

    fn parse_global_var(&self, node: &Node) -> Option<GlobalVar> {
        let type_annotation = node.child_by_field_name("type")
            .map(|t| self.get_node_text(&t))
            .unwrap_or_default();

        let declarator = node.child_by_field_name("declarator")?;
        let name = self.extract_declarator_name(&declarator);

        if name.is_empty() {
            return None;
        }

        let line = node.start_position().row + 1;

        let value = declarator.child_by_field_name("value")
            .or_else(|| node.child_by_field_name("value"))
            .map(|v| self.get_node_text(&v));

        Some(GlobalVar {
            name,
            type_annotation,
            value,
            line,
        })
    }

    fn extract_docstring(&self, node: &Node) -> String {
        if let Some(prev) = node.prev_sibling() {
            if prev.kind() == "comment" {
                let text = self.get_node_text(&prev);
                return text
                    .trim_start_matches("//")
                    .trim_start_matches("/*")
                    .trim_end_matches("*/")
                    .trim()
                    .to_string();
            }
        }
        String::new()
    }

    fn calculate_complexity(&self, node: &Node) -> usize {
        let mut complexity = 1;

        fn count_complexity_nodes(node: &Node) -> usize {
            let mut count = 0;
            let mut cursor = node.walk();

            match node.kind() {
                "if_statement" | "for_statement" | "while_statement" |
                "do_statement" | "switch_statement" | "case_statement" |
                "conditional_expression" | "&&" | "||" => {
                    count += 1;
                }
                _ => {}
            }

            for child in node.children(&mut cursor) {
                count += count_complexity_nodes(&child);
            }

            count
        }

        complexity += count_complexity_nodes(node);
        complexity
    }

    fn extract_todos(&self) -> Vec<Todo> {
        let re = Regex::new(r"(?://|/\*)\s*TODO:?\s*(.+?)(?:\*/|$)").unwrap();

        self.source_code
            .lines()
            .enumerate()
            .filter_map(|(idx, line)| {
                re.captures(line).map(|caps| {
                    let text = caps.get(1).unwrap().as_str().trim().to_string();
                    let priority = if text.to_lowercase().contains("critical") ||
                                      text.to_lowercase().contains("urgent") {
                        "high"
                    } else if text.to_lowercase().contains("minor") {
                        "low"
                    } else {
                        "medium"
                    };

                    Todo {
                        line: idx + 1,
                        text,
                        priority: priority.to_string(),
                    }
                })
            })
            .collect()
    }

    fn detect_security_patterns(&self) -> Vec<SecurityNote> {
        let mut notes = Vec::new();

        let patterns = vec![
            (r"strcpy|strcat|sprintf|vsprintf|gets", "unsafe_string", "Uses unsafe string function"),
            (r"system\(|popen\(|exec", "command_execution", "System command execution"),
            (r"malloc|calloc|realloc|free", "manual_memory", "Manual memory management"),
            (r"scanf|fscanf", "unsafe_input", "Potentially unsafe input function"),
            (r"memcpy|memmove|memset", "memory_operation", "Direct memory operation"),
            (r"setuid|setgid|seteuid", "privilege_change", "Changes privilege level"),
            (r"rand\(\)|random\(\)", "weak_random", "Weak random number generator"),
        ];

        for (pattern, note_type, description) in patterns {
            if let Ok(re) = Regex::new(pattern) {
                for (idx, line) in self.source_code.lines().enumerate() {
                    if re.is_match(line) {
                        notes.push(SecurityNote {
                            note_type: note_type.to_string(),
                            line: idx + 1,
                            description: description.to_string(),
                        });
                    }
                }
            }
        }

        notes
    }

    fn auto_tag_function(&self, name: &str, docstring: &str, calls: &[FunctionCall], return_type: &str) -> Vec<String> {
        let mut tags = Vec::new();
        let name_lower = name.to_lowercase();
        let doc_lower = docstring.to_lowercase();

        // Entry point
        if name == "main" {
            tags.push("entry-point".to_string());
        }

        // Initialization
        if name_lower.contains("init") || name_lower.contains("setup") ||
            name_lower.contains("initialize") || name_lower.contains("bootstrap") {
            tags.push("initialization".to_string());
        }

        // Cleanup
        if name_lower.contains("free") || name_lower.contains("cleanup") ||
            name_lower.contains("destroy") || name_lower.contains("dispose") ||
            name_lower.contains("close") || name_lower.contains("shutdown") {
            tags.push("cleanup".to_string());
        }

        // Authentication & Security
        if name_lower.contains("auth") || name_lower.contains("login") ||
            name_lower.contains("logout") || name_lower.contains("password") ||
            name_lower.contains("hash") || name_lower.contains("encrypt") ||
            name_lower.contains("decrypt") || name_lower.contains("token") ||
            doc_lower.contains("authentication") {
            tags.push("authentication".to_string());
            tags.push("security".to_string());
        }

        // API & HTTP
        if name_lower.contains("api") || name_lower.contains("endpoint") ||
            name_lower.contains("route") || name_lower.contains("handler") ||
            name_lower.contains("serve") || doc_lower.contains("http") {
            tags.push("api".to_string());
        }

        if name_lower.contains("handler") || name_lower.contains("serve") {
            tags.push("http-handler".to_string());
        }

        // Database
        if name_lower.contains("db") || name_lower.contains("database") ||
            name_lower.contains("query") || name_lower.contains("select") ||
            name_lower.contains("insert") || name_lower.contains("update") ||
            name_lower.contains("delete") {
            tags.push("database".to_string());
        }

        // Validation
        if name_lower.contains("validate") || name_lower.contains("check") ||
            name_lower.contains("verify") || name_lower.contains("sanitize") {
            tags.push("validation".to_string());
        }

        // Error handling
        if name_lower.contains("error") || name_lower.contains("handle") && doc_lower.contains("error") {
            tags.push("error-handling".to_string());
        }

        // Utilities
        if name_lower.contains("util") || name_lower.contains("helper") {
            tags.push("utility".to_string());
        }

        // Testing
        if name_lower.starts_with("test") || name_lower.contains("test_") {
            tags.push("testing".to_string());
        }

        // File I/O
        if name_lower.contains("read") || name_lower.contains("write") ||
            name_lower.contains("file") || name_lower.contains("open") {
            tags.push("file-io".to_string());
        }

        // Network
        if name_lower.contains("socket") || name_lower.contains("connect") ||
            name_lower.contains("send") || name_lower.contains("receive") {
            tags.push("network".to_string());
        }

        // Configuration
        if name_lower.contains("config") || name_lower.contains("setting") {
            tags.push("configuration".to_string());
        }

        // Logging
        if name_lower.contains("log") || name_lower.contains("debug") {
            tags.push("logging".to_string());
        }

        // Parsing
        if name_lower.contains("parse") || name_lower.contains("decode") {
            tags.push("parsing".to_string());
        }

        // Serialization
        if name_lower.contains("serialize") || name_lower.contains("encode") {
            tags.push("serialization".to_string());
        }

        // Memory management
        if calls.iter().any(|c| c.callee.contains("malloc") ||
                                c.callee.contains("calloc") ||
                                c.callee.contains("realloc") ||
                                c.callee.contains("alloca")) {
            tags.push("allocates-memory".to_string());
            tags.push("memory-management".to_string());
        }

        if calls.iter().any(|c| c.callee.contains("free")) {
            tags.push("frees-memory".to_string());
            tags.push("memory-management".to_string());
        }

        // Pointer operations
        if return_type.contains('*') {
            tags.push("returns-pointer".to_string());
        }

        // System calls
        if calls.iter().any(|c| c.callee.contains("syscall") ||
                                c.callee.contains("ioctl") ||
                                c.callee.contains("fcntl")) {
            tags.push("system-call".to_string());
        }

        // Threading/Concurrency
        if calls.iter().any(|c| c.callee.contains("pthread") ||
                                c.callee.contains("fork") ||
                                c.callee.contains("thread")) {
            tags.push("concurrent".to_string());
            tags.push("threading".to_string());
        }

        // String operations
        if calls.iter().any(|c| c.callee.contains("strcpy") ||
                                c.callee.contains("strcat") ||
                                c.callee.contains("sprintf") ||
                                c.callee.contains("strncpy")) {
            tags.push("string-operations".to_string());
        }

        // Signal handling
        if name_lower.contains("signal") || calls.iter().any(|c| c.callee.contains("signal")) {
            tags.push("signal-handling".to_string());
        }

        // Remove duplicates and sort
        tags.sort();
        tags.dedup();
        tags
    }

    fn estimate_importance(&self, name: &str, return_type: &str) -> f32 {
        let mut score: f32 = 0.5;

        if name == "main" {
            score += 0.3;
        }

        if name.starts_with('_') {
            score -= 0.1;
        }

        if return_type.contains("static") {
            score -= 0.1;
        }

        score.max(0.0).min(1.0)
    }

    fn get_node_text(&self, node: &Node) -> String {
        node.utf8_text(self.source_code.as_bytes())
            .unwrap_or("")
            .to_string()
    }
}

pub fn parse_file(path: &Path) -> Result<(String, FileData), String> {
    let source_code = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read file {}: {}", path.display(), e))?;

    let parser = CParser::new(source_code);
    let file_data = parser.parse()?;

    let relative_path = path.to_string_lossy().to_string();

    Ok((relative_path, file_data))
}
